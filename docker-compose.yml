# docker-compose.yml
version: '3.8' # Use a recent version for latest features

services:
  db:
    image: postgres:14-alpine # Or your preferred database image (mysql, mongo, etc.)
    restart: always
    environment:
      # Use the GCAR_PG_ variables directly for the PostgreSQL container
      # These will be picked up from the .env file that docker-compose automatically loads
      # from the root directory, or if you explicitly define them here.
      # For simplicity, we assume the root .env or a shared .env will provide these.
      # If your backend/.env is the *only* source, you might need to duplicate these
      # or ensure a shared .env has them. For now, let's assume the root .env has them,
      # or they are passed via the command line for the db service.
      # However, for the app to connect, it will use the backend/.env values.
      POSTGRES_USER: ${GCAR_PG_USER}
      POSTGRES_PASSWORD: ${GCAR_PG_PASSWORD}
      POSTGRES_DB: ${GCAR_PG_DB}
    volumes:
      - db_data:/var/lib/postgresql/data # Persistent data volume
    ports:
      - "5433:5432" # Expose container's 5432 to host's 5433, matching GCAR_PG_PORT
    healthcheck: # Added healthcheck to ensure DB is ready
      test: ["CMD-SHELL", "pg_isready -U ${GCAR_PG_USER} -d ${GCAR_PG_DB}"]
      interval: 5s
      timeout: 5s
      retries: 5

  app: # Your application service (e.g., Node.js with Knex)
    build: ./backend # Or image: your_app_image
    restart: always
    ports:
      - "${PORT}:${PORT}" # Maps host_port:container_port
    # Pass the entire backend/.env file to the app container
    env_file:
      - ./backend/.env # Pointing to the .env file within the backend directory
    depends_on:
      db:
        condition: service_healthy # Ensure app starts only after db is healthy

volumes:
  db_data:
