# docker-compose.yml
version: '3.8' # Use a recent version for latest features

services:
  pgdb:
    image: postgres:14-alpine # Or your preferred database image (mysql, mongo, etc.)
    restart: always
    environment:
      POSTGRES_USER: ${GCAR_PG_USER}
      POSTGRES_PASSWORD: ${GCAR_PG_PASSWORD}
      POSTGRES_DB: ${GCAR_PG_DB}
    volumes:
      - db_data:/var/lib/postgresql/data # Persistent data volume
    ports:
      - "5433:5432" # Expose the database port to your host (optional, for direct connection)

  # app: # Your application service (e.g., Node.js with Knex)
  #   build: . # Or image: your_app_image
  #   restart: always
  #   ports:
  #     - "3000:3000" # Example port for your app
  #   environment:
  #     # DATABASE_URL: postgres://${DB_USER}:${DB_PASSWORD}@db:${DB_PORT}/${DB_NAME}
  #     # # Or individual variables for your app to pick up:
  #     DB_HOST: ${GCAR_DB_HOST}
  #     DB_PORT: ${GCAR_DB_PORT}
  #     DB_USER: ${GCAR_DB_USER}
  #     DB_PASSWORD: ${GCAR_DB_PASSWORD}
  #     DB_NAME: ${GCAR_DB_NAME}
  #   depends_on:
  #     - db # Ensures db starts before app
    # If your app uses Knex and needs to run migrations/seeds inside the container
    # Consider an entrypoint script or running commands explicitly:
    # entrypoint: ["/bin/sh", "-c", "npm install && npm run migrate:latest && npm start"]
    # This might be more complex if you have separate build/run stages.
    # For development, you often run migrations from your host.

volumes:
  db_data: